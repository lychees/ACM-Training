网格图上的简单路径问题，而且m的范围相当小，很容易想到基于联通性的状态压缩动态规划，具体可以参考陈丹琦的论文，在这题上我采用的是基于轮廓线的按格dp，其基本原理是依次考虑某行某列的格子时，之前的格子中会影响到它和它的后续格子的决策情况的，只有该行在该列左边和上一行在该列右边的那些格子，我们记录下相关信息并进行决策。下面我将对解法进行简单的讨论。
我们仔细观察一条路径，可以注意到，由于路径自己不会相交，那么一旦确定了哪些格子属于路径，也就是被标记上C的话，那么路径，路径的顺序，路径的长度（也就是C的个数）都可以依次确定了。
所以我们的算法就是利用动态规划，依次确定每个格子是否被路径覆盖。
但是并非任意选择路径中的格子都可以组成一条完整的路径的，我们需要保证：1.除了首尾的两个格子外，与之相邻的格子有且仅有两个。2.选择的格子一定要求四联通。3.在此基础上，不会出现如上第二种相交情况。
第三个问题很容易解决，我们只需要在选择某个格子的时候判断其周围格子的存在情况，所以记录下轮廓线上是否放置了格子即可，具体留给读者自行思考。
至于保证格子的度数和连通性，有两种比较经典的办法：

第一种，我们想办法记录下轮廓线上每个格子的有无，以及其度数，然后用最小表示法标号存下所有格子的连通性。这样，每次加入新的格子时，计算出新的轮廓线上的状态，判断掉非法的情况：比如说度数>2，或者某个连通块消失了，或者某个格子的度数最终是1啊等等。
这样写起来比较粗暴，相对而言思维复杂度较小，但实际上加大了编程难度和常数。
所以实际上我采用的是第二种方法，也就是经典的插头dp。
插头dp的核心是观察到了路径的连通情况一定是两两连通的――因为一条路径不可能只有一个端点。如果确定一个点是左插头还是右插头，匹配情况可以通过栈快速地处理出来。
这样，我们需要记录的轮廓线上的格子的可能状态有5种：
0 表示这儿没有格子。
1 表示这儿有个格子，但是不是插头――也就是说度数已经等于2了。
2 这是个左插头
3 这是个右插头
4 这是个独立插头――因为这儿求的不是回路，所以整条路径的两端在轮廓线上会形成一个单独的插头。
那么加入一个点，插头的情况会进行相应的改变，分别进行讨论即可，还是蛮简单的。
注意一种特殊情况，一个格子可能既是左插头又是右插头，另外用一种状态记下或者特殊处理就行了。

这样，有了状态表示之后问题就非常简单了，依次考虑每个格子的决策，计算出新的状态，然后进行递推。
最后一个格子的最优值即为答案。