
\chapter{ACM/ICPC World Finals 2013~(11/11)}

\section{[A]Self-Assembly}
\subsection{题意简述}
正方形四面贴形如``符号+字符''（符号为~$+-$，字符为大写~$A\sim Z$）的标签，只有符号相反，字符相同的两个标签所在边才能贴在一起。但特殊标签``00''和所有标签都 不能贴在一起。问用无限个给出~$n$~种的正方形，能否拼成无限的图案。

【数据范围】$n\leq 40000$。
\subsection{算法分析}
如果可以构成循环，那么图案就是无限的。如果把正方形中的一个标签到其他标签的配对标签看作一条边，那么就相当于找一条从某个标签回到它自己的路径，可以证明只要有路径一定可以一直往右上方向连构成循环，而不会回到它本身。所以只要在读入每种正方形后连边，用~$floyd$~判断能否从自己走到自己即可。

【时间复杂度】$O({(2\times \left|S\right|)}^3+4^2n)$，【空间复杂度】$O({(2\times \left|S\right|)}^2)$。

\section{[B]Hey, Better Bettor}
\subsection{题意简述}
有一个赌场给出如下的优惠政策：亏损~$k$~元后可以申请补偿亏损的~$x\%$~，但只能使用一次，注意这个~$k$~是指总支出-总收益，且大于~$0$~。每一场赌局开始将付~$1$~块钱，如果赌赢了将得到~$2$~块钱。现在给出每一场赢的概率~$p\%$~，问你在最优策略下期望能赚多少钱。

【数据范围】$0\leq x<100,0\leq p<50$。
\subsection{算法分析}
由于当前状态只和钱有关，可知只有在亏损~$a$~元或赢~$b$~元之后才会停止赌博。首先若~$p$~为~$0$~，则答案为~$0$~，下面不考虑~$p=0$~的情况。令~$p$~为读入的~$p/100~,~\lambda=1-x\%~,~f(x)$~ 为在当前赢得~$x$~ 元的情况下的最大期望收益，则~$f(-a)=-\lambda a,f(b)=b$~。\\
又有
    \[f(x)=p~f(x+1)+(1-p)f(x-1)\]
移项得
    \[f(x+1)=\frac{f(x)}{p}-\frac{(1-p)f(x-1)}{p}\]
令~$g(x)=f(x-a)$~，列出特征根方程
    \[x^2=\frac{x}{p}-\frac{1-p}{p}\]
解得~$x_1=1,x_2=\frac{1-p}{p}~,~\because p<0.5~,~\therefore x_1\neq x_2$
    \[\therefore g(n)=c_1{x_1}^n+c_2{x_2}^n=c_1+c_2{\left(\frac{1-p}{p}\right)}^n\]
将~$g(0)=f(-a)=-\lambda a,g(a+b)=f(b)=b$~代入得
    \[c_1+c_2=-\lambda a,c_1+c_2{\left(\frac{1-p}{p}\right)}^{a+b}=b~,~\therefore c_2=\frac{b+\lambda a}{{\left(\frac{1-p}{p}\right)}^{a+b}-1}\]
    \[\therefore f(0)=g(a)=c_1+c_2{\left(\frac{1-p}{p}\right)}^a
                     =\frac{(b+\lambda a)\left({\left(\frac{1-p}{p}\right)}^a-1\right)}{{\left(\frac{1-p}{p}\right)}^{a+b}-1}-\lambda a\]

由打表或者求导可知~$f(0)$~关于~$a,b$~都是单峰函数，又由于~$a,b$~均为整数，可用二分套二分。

关于二分上界，由偏导为~$0$~可大概得出为~$\frac{10}{\log_{10}\left(\frac{1-p}{p}\right)}$。

【时间复杂度】$O(\log^2)$，【空间复杂度】$O(1)$。

\section{[C]Surely You Congest}
\subsection{题意简述}
$n$~个顶点，$m$~条边的带权无向图，有~$c$~辆车要分别从某些顶点以他所能达到的最短时间（无视其他车的干扰时）到达~$1$~号点。不能有两辆车在同一时间从同一顶点沿同一条边行驶。若所有车同时出发，问最多有多少车可以按时到达~$1$~号点。

【数据范围】$n\leq 25000~,~m\leq 50000~,~c\leq 1000~,~1\leq$~边权~$\leq10000$。
\subsection{算法分析}
令~$d_i$~为顶点~$i$~到顶点~$1$~的最短路，取出满足~$d_i+w_{i,j}=d_j$~的边~$(i,j)$~，在新建的图中加入有向边~$(j,i)$~。容易发现新建的图为~$DAG$~，并且沿着图中的有向边走到顶点~$1$~肯定是最短路径。

然后考虑开始时在顶点~$i$~和顶点~$j$~的两个人，假如他们同时到达了顶点~$k$~，容易说明~$d_i=d_j$~。并且如果~$d_i=d_j$~，他们到达相同顶点时的时间也一定相同。这样的话，将人按照出发顶点的~$d$~值分组，不同组的人是不会影响的。每组的最优解是个简单的最大流问题。

由于时限~$10s$~，直接暴力做最大流就能~$AC$~了。

【时间复杂度】$O(spfa(n,m)+c\times MaxFlow(DAG(n,m)))$，

【空间复杂度】$O(n+m)$。

\section{[D]Factors}
\subsection{题意简述}
定义~$f(x)$~为把~$x$~分解成质数相乘的形式不同的排列方案数，如~$20=2\times 2\times 5=2\times 5\times 2=5\times 2\times 2$，则~$f(20)=3$~。给出~$T$~组~$n$~，求最小的~$x$~ 满足~$f(x)=n$。

【数据范围】$T\leq 1000~,~n,x\leq 2^{63}$。
\subsection{算法分析}
若\[x=\prod_{i=1}^{k}{p_i}^{q_i}\]

则\[f(x)=\frac{(\sum_{i=1}^{k}q_i)!}{\prod_{i=1}^{k}q_i!}\]

因为要满足~$x$~最小，所以~$q_i$~不递增，又因为~$x\leq 2^{63}$~，所以实际有效的~$x$~不多，直接~$dfs$~预处理出所有有效的~$x$~，按~$f(x)$~存入~$Hash$~表中，保留最小的~$x$~。询问直接查询~$Hash$~表即可。可用~$STL$~的~$map$~替代~$Hash$~表。

【时间复杂度】$O(~(\left|S\right|+T)[\log{\left|S\right|}]~)$，【空间复杂度】$O(\left|S'\right|)$。

其中~$\left|S\right|$~为有效的~$x$~的数量，~$\left|S'\right|$~为有效的~$f(x)$~的数量。

\section{[E]Harvard}
\subsection{题意简述}
有~$n$~个内存块，每个内存块有~$m$~个内存。在内存中读取变量需要进行操作，有~$3$~种操作：读取~$0$~号内存块的某个内存上的变量、读取~$x$~号内存块的某个内存上的变量、指定~$x$~的值。给~$s$~个变量分配内存，使得仅包含循环和读取变量的语句数为~$L$~的程序需要的操作数最少。初始~$x$~的值未定义。

【数据范围】$n,m,s\leq 13$，$L\leq10^3$，循环展开后语句数~$\leq{10}^{12}$。
\subsection{算法分析}
首先所有读取变量都需要一次操作，所以只需计算相邻两次需要用到第二个操作但~$x$~不同的次数。所以操作次数只和一个变量和哪些变量在同一个内存块中有关。而~$0$~号内存块比较特殊，放入其中的变量的读取操作可以忽略。所以先~$dfs$~确定~$0$~号内存块中的变量，然后用栈预先算出程序中变量两两相邻（在去掉在~$0$~号内存块中的变量后）的次数，最后~$dfs$~ 其余的分组方式，边~$dfs$~ 边计算需要的操作数，方便进行最优性剪枝。

【时间复杂度】$O(\binom{s}{m}\times(L+\href{http://en.wikipedia.org/wiki/Bell_number}{bell}(s-m)\times s^2))$，【空间复杂度】$O(L)$。

\section{[F]Low Power}
\subsection{题意简述}
有~$n$~个机器，每个机器有~$2$~个芯片，每个芯片可以放~$k$~个电池。

每个芯片能量是~$k$~个电池的能量的最小值。

两个芯片的能量之差越小，这个机器就工作的越好。

现在有~$2nk$~个电池，已知它们的能量，我们要把它们放在~$n$~个机器上的芯片上，

使得所有机器的能量之差的最大值最小。

【数据范围】$2nk\leq 10^6~,~p_i\leq 10^9$。
\subsection{算法分析}

答案显然满足二分性质，设二分值为~$x$~。

假设最后选了~$2n$~个关键电池作为每个芯片的最小值，最优方案中一定是能量相邻的两个配对。

那么从前往后决定每个电池是否为关键电池。在选了某个配对中的第一个电池后，第二个电池的能量要尽可能与第一个电池接近，而关键电池的能量越小，方案越容易合法。所以这时一定是把紧接的一个电池设为关键电池。

那么可以~$DP$~，用~$f[i]$~表示前~$i$~个电池中最多选了几对关键电池，而且要满足~$f[i]\times 2\times k\geq i$~才能进行转移。

转移即第~$i$~个不选，则~$f[i+1]=\max(f[i+1],f[i])$~，或第~$i$~个和~$i+1$~个作为配对的关键电池，且满足~$p[i+1]-p[i]\leq x$~，则~$f[i+2]=\max(f[i+2],f[i]+1)$~。

最后判断~$f[2nk]\geq n$~是否成立即可。

【时间复杂度】$O(n\log{n}$，【空间复杂度】$O(n)$。


\section{[G]Map Tiles}
\subsection{题意简述}
把n条边的多边形铺在平面上（不可旋转），使其占用网格数最少。每个网格大小为~$xs\times ys$~。

【数据范围】$n\leq 50~,~xs,ys\leq 100~,~0\leq x_i\leq 10xs~,~0\leq y_i \leq 10ys$。
\subsection{算法分析}
由数据范围可知每行每列最多使用~$m=11$~个网格。

肯定有一种最优方案是某些点或边卡在网格的边界上，则要分以下情况讨论：
\begin{enumerate}[itemindent=1em]
  \item 卡两点，则分别枚举~$x,y$~方向卡住的两点后计算。
  \item 卡点边，需要枚举~$x$~或~$y$~方向卡住的点，然后枚举边，并枚举在边上卡住的点相对于点在卡住方向上的距离（肯定为整数），求交点以确定卡住的点。
  \item 卡两边，需要枚举两边，然后枚举卡在边上的两个点在~$x,y$~方向的距离（肯定为整数），将一边平移后求交点确定卡住的点。
\end{enumerate}

这样总共有~$O(n^2m^2)$~种卡住的方案，但有较多重复，可将偏移量取小数部分，用~$set$~去重。

现在已经得到了最终地图的位置，需要计算其覆盖的网格个数，分两类：被边穿越的，或在多边形内部的。

其中被穿越可以用网格的~$4$~条边和多边形的边分别求交判断，要特判刚好卡在边界上的情况。在内部的可以把网格中心作为判定点，用射线法分别与多边形的边求交后判断。这样可以~$O(nm^2)$~完成判断，加些常数优化以加速。

还有一种~$O(mn\log n)$~的方法，枚举每行，用多边形每条边和该行顶部和底部求交，记录穿越的交点。把从下到上穿越记为~$+1$~，否则记为~$-1$~，把交点排序后可看作括号匹配，括号内部分均为覆盖部分，扫一遍即可求出覆盖网格数。

【时间复杂度】$O(n^3m^4)$\quad $O(n^3m^3\log{n})$，【空间复杂度】$O(n+m^2)$。


\section{[H]Матрёшка}
\subsection{题意简述}
有一行~$n$~个单层套娃，大小为~$a_i$~，每个套娃可以直接放入更大的单层套娃中。每次操作可以合并相邻两个套娃，合并时打开并关闭~$1$~个套娃的代价为~$1$~，套娃合并后不可拆分。问把这些单层套娃合并成若干个完整套娃（大小为从~$1$~开始的连续正整数，层数若干）需要的最少代价。

【数据范围】$n,a_i\leq 500$。
\subsection{算法分析}
两个套娃合并，设两套中分别的最小值中较大的值为~$x$~，则代价为~总数量~$-$~另一套中大小~$<x$~的套娃数量。这个通过预处理一段中的最小值，以及前~$i$~个套娃中大小~$\leq j$~的数量后可~$O(1)$~算出。用~$f[i][j]$~表示~$[i,j]$~段套娃合并所需的最小代价，转移为~$f[i][j]=\min\{f[i][k]+f[k+1][j]+cost(i,k,j)\}$~。最后把完整的套娃再~$DP$~一遍即可。

【时间复杂度】$O(n^3)$，【空间复杂度】$O(n^2)$。

\section{[I]Pirate Chest}
\subsection{题意简述}
$n\times m$~的水池，每格深度为~$d_{i,j}$~，把底面为~$x\times y$~的宝箱放入其中（要求~$x,y$~满足其中一个~$<a$~，另一个~$<b$），宝箱会被最浅的格子卡住。若宝箱高度可为任意非负整数，问在保证宝箱不露出水面的情况下，宝箱体积最大为多少。

【数据范围】$a,b,n,m\leq 500~,~d_{i,j}\leq 10^9$。
\subsection{算法分析}
在已知底面，得出宝箱卡住的深度后，可以通过计算直接得出宝箱最大的高度。关键是求卡住的深度。

假设~$a\geq b$~，枚举~$x$~，则~$x>b$~时~$y$~要满足~$y\leq a$~，否则要满足~$y\leq b$~。
随着~$x$~的增大，不断合并相邻行，可得到每个~$x\times 1$~的矩形中的最小值，然后利用这些值每行分别计算。
观察式子后发现~$x$~和卡住深度确定后，~$y$~显然越大越好，所以确定出每个值作为最小值的区间后让~$y$~尽可能大。
而每个值作为最小值的区间可以建成\href{http://en.wikipedia.org/wiki/Cartesian_tree}{笛卡尔树}后得出。

【时间复杂度】$O(n^3)$，【空间复杂度】$O(n^2)$。


\section{[J]Pollution Solution}
\subsection{题意简述}
给出一个在~$x$~轴上方，~$n$~个点的多边形以及一个半径为~$r$~半圆，求多边形被半圆覆盖的面积。

【数据范围】$n\leq 100,r\leq 1000$。
\subsection{算法分析}
对比多边形面积的求法， 我们可以将问题简化为求一个三角形被半圆覆盖的面积，然后根据两个顶点表示的向量的叉积的值，将各个面积加减得到答案。

此时，三角形的一个顶点必在圆心。我们可以分~$4$~类情况讨论:
\begin{enumerate}[itemindent=1em]
\item 三角形其余两个顶点均在半圆内部，那么答案就是三角形的面积；
\item 三角形两个顶点均在半圆外部，并且第三条边与圆弧交点小于两个，那么答案就是一个扇形的面积；
\item 三角形一个顶点在半圆外部，那么答案化为一个三角形和一个扇形的面积和；
\item 三角形两个顶点均在半圆外部，并且第三条边与圆弧有两个交点，那么答案就是一个三角形和两个扇形的面积和。
\end{enumerate}

对于第~$2$~类和第~$4$~类的情况可以用点到线段的距离来判定，但是比较麻烦，其实可以将后三类情况一起判断，直接使用解二次方程的方法判断和圆弧交点的个数以及交点的位置，然后第~$4$~类可以通过垂足拆分转化为第~$3$~类，第~$3$~类可通过交点拆分转化为第~$2$~类，这样计算就比较方便了。

【时间复杂度】$O(n)$，【空间复杂度】$O(n)$。

\section{[K]Up a Tree}
\subsection{题意简述}
给出把树的前序、中序、后序遍历的递归过程中的过程调用打乱（比如前序遍历中调用了对左子树调用了中序遍历过程，而对右子树调用了后序遍历过程）后产生~$n$~个节点的树的``前序''，``中序''，``后序''遍历。问可能的打乱情况和在这种打乱情况下字典序最小的树的前序、中序、后序遍历（字典序先比前序，再比中序）。

【数据范围】$n\leq 26$。
\subsection{算法分析}
先枚举~$6$~个递归调用分别是什么，然后用给出的三个输出进行搜索，搜索的参数为错误前序、中序、后序遍历程序对应的输出，由于它的递归调用可能错的，不能保证到任何一个子树，都存在每种输出，但不难说明至少存在一个输出。这样搜索中可能需要枚举根或者左子树的大小。

用~$map$~进行记忆化。

【时间复杂度】$O(3^3\times n^4[\times \log{n}])$，【空间复杂度】$O(3^3\times n^3)$。
