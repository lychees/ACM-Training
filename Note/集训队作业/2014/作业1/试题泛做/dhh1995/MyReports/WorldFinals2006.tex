
\chapter{ACM/ICPC World Finals 2006~(10/10)}

\section{[A]Low Cost Air Travel}
\subsection{题意简述}
有~$m$~种机票，该飞机依次经过~$L_i$~个点，只能从起点登机，可以在任意中途点离开。

要完成~$Q$~次旅行，每次旅行要依次经过~$L_j$~个点，求每次旅行的最小费用以及方案（保证唯一）。

【数据范围】$Q,m\leq 20~,~L\leq 10$。
\subsection{算法分析}
$f[i][j]$~表示经过了这次旅行的第~$i$~个点，且当前在~$j$~点的最小费用，由于~$i$~相同时会互相转移，用~$dijkstra$~完成这些转移，即先找费用最小的点，枚举飞机票以及终点来转移。转移时记录下出发时已经经过的点数和使用的机票，递归输出方案。

【时间复杂度】$O(Qm^2L^3)$，【空间复杂度】$O(mL^2)$。

\section{[B]Remember the A La Mode!}
\subsection{题意简述}
给出~$n$~种薄饼和~$m$~种冰淇淋的份数，以及每种薄饼和冰淇淋搭配的收益，求最大的收益。

【数据范围】$n,m\leq 50$。
\subsection{算法分析}
源点向薄饼连费用为0，容量为薄饼份数的边，冰淇淋向汇点连费用为0，容量为冰淇淋份数的边，薄饼和冰淇淋之间连费用为收益，容量无限的边。
求最大费用最大流。

【时间复杂度】$O(CostFlow(V=n,E=n^2))$，【空间复杂度】$O(n^2)$。

\section{[C]Ars Longa}
\subsection{题意简述}
给出用~$m$~根杆子连接~$n$~个等质量的球的雕塑（在底面上的球已固定），问其能否静止，若静止，是否稳定（某些点施加某些力不移动）。

【数据范围】$n,m\leq 100$。
\subsection{算法分析}
每根杆子对两段的球施加的力设为未知数，每个不在地面的点需要满足合力（包括重力）为~$0$~，根据这些等式的列方程，然后高斯消元求解，有解说明静止。

若静止，给每个点一个随机的力，若仍有解，则稳定。

【时间复杂度】$O(n^2m)$，【空间复杂度】$O(nm)$。

\section{[D]Bipartite Numbers}
\subsection{题意简述}
求比~$x$~大且为~$x$~的倍数的最小的二段数。二段数定义为~$m$ $s$ $n$ $t$~，即~$m$~个~$s$~后面接~$n$~个~$t$~组成的数，要求~$0<s<10~,~0\leq t<10~,~s\neq t~,~m>0~,~n>0$。

【数据范围】$0<x<10^5$。
\subsection{算法分析}
首先预处理~$i$~个~$1 \mod x$~的结果~$f(i)$~，则在知道~$m$ $s$ $n$ $t$~后可~$O(1)$~算出其~$\mod x$~的值，即~$(f(m+n)\times s+f(n)\times (t-s))\mod x$~。

接下来直接暴力枚举~$n+m$~，然后枚举~$n,s,t$~。其中枚举~$t$~的部分可以优化，根据~$x$~的个位数，~$t$~取某些值时是肯定不可能整除了，不需要枚举。

但这样仍旧是~$TLE$~，将部分答案打表后发现~$x$~的个位为~$0$~时答案较大，而这时~$t$~一定是~$0$~，但~$n$~过大是没有必要的，~$0$~的个数的增加只能增加~$2$~和~$5$~的因子个数，而~$10^5$~以内，且个位为~$0$~的数中因子~$2$~的个数最多为~$14$~，而~$s=8$~时可以抵~$3$~个~$2$~，所以~$0$~的个数最多只要~$11$~个，所以~$n$~只需要枚举到~$11$~。

加了这个优化后速度快了不少，就能通过数据了。

【时间复杂度】$O(~(m+n)\times n\times 10^2)$，【空间复杂度】~$O(n+m)$~。

\section{[E]Bit Compressor}
\subsection{题意简述}
一次压缩指~只要能使~$01$~串的长度减少，就把最长的连续~$n$~个~$1$~替换为~$n$~的二进制表示。

给出压缩后的长度为~$m$~的串~$S$~，求原始串长为~$L$~，且其中~$1$~的个数为~$N$~的串的个数，只需回答是多解，唯一解，还是无解即可。

【数据范围】~$m\leq 40,N\leq L\leq 128000$~。
\subsection{算法分析}
由于只需回答多解或唯一解或无解，所以最多只需得到两组解。又因为数据范围较小，可直接搜索，搜到第二组解即可退出。

搜索时记录当前解压位置，解压后的长度和~$1$~的个数，枚举下一段解压的数后看这样解压是否合法即可。由于解压前后必须是~$0$~，所以搜索相当于枚举哪些~$0$~作为原始数据，所以复杂度是~$O(2^m)$~。

【时间复杂度】$O(2^m)$，【空间复杂度】~$O(m)$~。

\section{[F]Building a Clock}
\subsection{题意简述}
给出~$n$~个齿轮的齿数，以及原始转轴的转速，要求通过转轴和齿轮构造出分针和时针的转速。求把转轴数、齿轮数、方案字典序分别作为第一、二、三关键字后最小的方案。

两咬合的齿轮的转速$\times$齿数的值为相反数，在同一转轴上的两齿轮转速相同。分针和时针可共用一部分转轴和齿轮。

【数据范围】$n\leq 6$。
\subsection{算法分析}
先搜索两者的公共部分，然后分别搜索分针和时针的方案。要注意使用全局变量(可选用char数组)来记录当前方案，如果用~$string$~传参数会影响复杂度。

可用估价函数剪枝，若当前转速为正，但不等于目标转速，那至少需要两个齿轮。如果为负，那么可能只需要一次，可预处理某种转速的齿轮是否存在，若根本不可能一个齿轮完成，那就至少需要两个齿轮了。若估价~$+$~当前齿轮数~$>n$~则剪枝。

【时间复杂度】$O(n!)$，【空间复杂度】$O(1)$。

\section{[G]Pilgrimage}
\subsection{题意简述}
~$A$~和另一群人旅行，~$A$~负责管理经费，途中会有人数增减，但~$A$~一直在这其中，~$A$~还在进行了记账，有~$4$~种条目：
\begin{enumerate}
  \item IN $k$，$k\leq 20$~表示加入~$k$~个人，新增的人每人需要缴纳这时钱的平均数。
  \item OUT $k$，$k\leq 20$~表示离开了~$k$~个人，离开的人每人得到这时钱的平均数。
  \item COLLECT $k$，$k \leq 200$~表示A向每个人收集了~$k$~元。
  \item PAY $k$，$k\leq 2000$~表示~$A$~支出~$k$~元。
\end{enumerate}

恰好的是，每种条目后钱仍旧是整数。现给出这个账本中的某一页（即这页开始的钱可以为任意数），求这页开始时的所有可能的人数。

【数据范围】账本中某一页条目数~$\leq 50$~。
\subsection{算法分析}
可以发现COLLECT不改变是否整除的情况，可以忽略。

只有在人数改变时才有可能发生不能整除的情况，又由于上一次人数改变后钱一定是当前人数的倍数，所以只需考虑这一段中总支出能否被平分即可。

考虑每一段PAY，统计总支出，则当时的人数肯定是该数量的约数，在第一段时统计出所有可能的解，之后逐一筛选。

【时间复杂度】$O(n\sqrt{n\times 2000})$，【空间复杂度】$O(n)$。

\section{[H]Pocket}
\subsection{题意简述}
把一张~$(n+1)\times (n+1)$~的纸用~$k$~次沿~$n$~条平行于坐标轴的折痕的折叠得到~$1\times1$~的形状。问最后形成的口袋的数量。

\includegraphics[width=31em]{WF06H}

【数据范围】$n,k\leq 64$。
\subsection{算法分析}
观察最后的纸片，只有在最外面的纸层才对答案有贡献，而且相邻两纸层之间会形成一个口袋。所以口袋数为所有在外面的纸层数量~$-4$~。

可以逐层展开来计算最后在外面的纸层。先将最后得到的~$1\times1$~的边界标记，然后每次根据操作和之后得到的结果倒推，维护当前图中正面和背面最后会在外面的折痕位置(翻转时，翻转面从正面变为背面，背面变为正面，需要判断是否会超出原范围)。注意边界的翻转对原位置的状态无影响。最后总的标记的折痕数量就是最后可见的折痕数。模拟时可直接用绝对位置来处理翻转，可以通过数据，但存在极端数据使数组存不下，但实际有效位置只有~$O(n^2)$~个，所以处理成相对位置即可。

【时间复杂度】$O(n^3)$，【空间复杂度】$O(n^2)$。

\section{[I]Degrees of Separation}
\subsection{题意简述}
~$n$~个人~$m$~对关系，一对关系用两个人名表示，求这个图中最短距离最远的两点之间的距离。

【数据范围】$n\leq 50$。
\subsection{算法分析}
先给每个人名一个编号（~$map$~或~$hash$~或~$sort$~判重均可），然后floyd或其他最短路算法求两点之间最短路，取最大的距离。

【时间复杂度】$O(n^3)$，【空间复杂度】$O(n^2)$。

\section{[J]Routing}
\subsection{题意简述}
~$n$~个点~$m$~条边的有向图中，选取最少的中转点，使起点到终点，终点到起点之间都有路径。

【数据范围】$n\leq 100$。
\subsection{算法分析}
显然有一种方案是不管重复点，直接使用两条最短路，但其实利用两条路径中的重合部分可以减少中转点的个数。

而两者公用路径形式为~$A\rightarrow C\rightarrow D\rightarrow B$~以及~$A\leftarrow D\leftarrow C\leftarrow B$~。其中有若干段~$CD$~。

那就可以~$DP$~，先用~$floyd$~预处理两点间最短距离，用~$f[i][j]$~表示当前第一条路径结束点为~$i$~，第二条路径出发点为~$j$~的最少中转点个数。若~$i\neq j$~，新增路径~$i\rightarrow j$~，则可转移到~$f[i][i]$~ 或~$f[j][j]$~或~$f[j][i]$~。或者新增路径$i\rightarrow x$，则转移到~$f[x][j]$~；新增$j\leftarrow y$，则转移到~$f[i][y]$~。用~$spfa$~或~$dijkstra$~完成转移。

【时间复杂度】$O(spfa(V=n^2,E=n^3))$，【空间复杂度】$O(n^2)$。
