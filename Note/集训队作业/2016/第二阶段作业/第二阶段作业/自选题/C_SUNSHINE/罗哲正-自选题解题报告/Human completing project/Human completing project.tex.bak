\documentclass{noiassignment}
\usepackage[CJKbookmarks,colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black]{hyperref}
\usepackage{CJKspace}

\begin{document}

%% 解题报告开始

\title{人类补完计划~解题报告}
\author{安徽师范大学附属中学~~罗哲正}

\maketitle

\section{试题来源}

UOJ Round 14 B.人类补完计划

连接：\url{http://uoj.ac/contest/28/problem/193}。

\section{试题大意}

    给出一张$n$个点$m$条边的基因图，对于一个边集的子集$S_e$，我们把所有与$S_e$中\textbf{至少}一条边相邻的点形成的集合称为$S_v$，$S_e$被称为\textbf{好的}当且仅当：

    1. $|S_e| = |S_v|$。

    2. 对于$S_v$中不同的两个点$x$和$y$，存在一条从$x$到$y$的路径使得路径中的边都属于$S_e$。

    设所有与$S_e$中\textbf{大于}一条边相邻的点的数量为$w$，那么这个边集的\textbf{权值}为$2 ^ w$。一张基因图的权值是所有\textbf{好的}边集的权值和。

    给出一张无向图求这张基因图的权值和对$998244353$取模的值。

    \subsection{限制与约定}

    每组测试数据的限制与约定如下所示：

\begin{tabular}{|c|c|c|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  测试点编号 & $n$的规模 & $m$的规模 \\
  \hline
  1 & \multirow{10}{*}{$n \leq 11$} & \multirow{4}{*}{$m \leq 20$} \\
  \cline{1-1}
  2 &  &  \\
  \cline{1-1}
  3 &  &  \\
  \cline{1-1}
  4 &  &  \\
  \cline{1-1}
  \cline{3-3}
  5 &  &  \\
  \cline{1-1}
  6 &  &  \\
  \cline{1-1}
  7 &  &  \\
  \cline{1-1}
  8 &  &  \\
  \cline{1-1}
  9 &  &  \\
  \cline{1-1}
  10 &  &  \\
  \cline{1-3}
  11 & $n \leq 13$ & $m = \frac{n(n-1)}{2}$ \\
  \cline{1-1}
  \cline{3-3}
  12 &  &  \\
  \cline{1-1}
  13 &  &  \\
  \cline{1-1}
  14 &  &  \\
  \cline{1-3}
  15 & $n \leq 14$ & $m = \frac{n(n-1)}{2}$ \\
  \cline{1-1}
  \cline{3-3}
  16 &  &  \\
  \cline{1-1}
  17 &  &  \\
  \cline{1-1}
  18 &  &  \\
  \cline{1-1}
  19 &  &  \\
  \cline{1-1}
  20 &  &  \\
  \hline
\end{tabular}

    对于所有数据， $1 \le n \le 14$, $0 \le m \le \frac{n(n - 1)}{2}$。

    $1 \le x_i, y_i \le n$，$x_i \ne y_i$，两个点之间最多只有一条边。

    时间限制：$1\texttt{s}$

    空间限制：$256\texttt{MB}$

\section{算法介绍}

    \subsection{算法1}

    对于$m \leq 20$的情况，我们可以暴力枚举每条边在不在$S_v$里，并判断是否符合题目要求，把合法的方案的权值加入答案中。

    时间复杂度$O\left(m2^m\right)$，期望得分20分。

    \subsection{算法2}

    观察题意其实就是枚举所有的基环外向树，$w$是非叶节点个数，把$2^w$加入答案。

    那么我们首先考虑基环外向树的计数，第一步是环的计数。
    环的计数可以非常容易的通过状态压缩DP来实现设$cir_{i,S}$表示集合$S$组成一条以$j$开头$i$结尾的链的方案数（令$j$为$S$中编号最小的元素），
    转移时枚举$i$的下一个元素即可，要求和$i$直接有边且编号$>j$，最后对于每对$i,S$，若$i,j$之间由有边，则将$cir_{i,S}$加入集合$S$的答案$f_S$中。
    注意一个环从$j$开始有两种不同的顺序遍历，所以最后答案要除以$2$。

    接下来考虑集合$V$组成的基环外向树计数$cnt_V$，我们可以枚举环的集合$S$，然后把环缩成点，直接套用Matrix-Tree定理即可，这样处理所有$V$的总复杂度是$O\left(3^n n^3\right)$的。

    我们考虑给权值一个意义，假设每个节点可以染成黑白两种颜色，叶子节点只能染成白色，那么只要计算染色的总方案数，一个$S_e$就会被恰好计算$w$次。

    对于染色方案数的计算，我们可以考虑容斥原理，用总方案数减去存在黑色叶子节点的方案数，注意到基环外向树删去叶子之后仍然是基环外向树。

    令$val_V = 2^{|V|}cnt_V$，枚举叶子节点集合$T$，则方案数

    $$g_V = \sum_{T \subset V,T \neq \emptyset} (-1)^{|T|} val_{V-T} ways(T,V-T)$$

    其中$ways(T,S)$表示$T$向$S$连边的方案数，为$T$中所有节点在$S$中邻接点个数之积，容斥时暴力计算就好，这部分时间复杂度是$O\left(3^n n\right)$的。

    于是这个算法总的复杂度就是$O\left(3^n n^3 \right)$，期望得分50分。

    \subsection{算法3}

    算法2的时间复杂度瓶颈在与求$cnt_V$上，我们考虑换一种计数方式，把$cnt_V$的计算和答案的计算放在一起。

    首先考虑$V$集合的权值和计算，对于$V$的每一个子集$T$，我们都计算出叶子节点集合为$T$的基环外向树个数$g_T$，那么权值和就可以直接计算了。

    依旧使用容斥原理，令$h_T = cnt_{V-T} ways(T,V-T)$，即$T$为叶子节点集合的子集的方案数，然后对$h$做子集反演得到$g$：

    $$ g_S =h_S - \sum_{S \subset T} (-1)^{|T|-|S|} h_T $$

    那么显然$V$集合对答案的贡献就是$2^{|V|}f_V+\sum_{S \subset V,S \neq \emptyset} 2^{|V|-|S|}g_S$。

    接下来考虑$cnt_V$如何计算，对于每个$V$首先把单独为一个环的情况$f_V$加入答案，
    然后既然我们已经求出了以任意集合$S$为叶子的基环外向树方案数$g_S$，直接把$cnt_V$加上所有$g_S$的和即可。

    计算$h_T$的总复杂度是$O\left(3^n n\right)$的，子集反演可以使用$O\left(2^n n\right)$的快速算法，总复杂度也是$O\left(3^n n\right)$，期望得分70分。

    \subsection{算法4}

    我们采用一种新的思考方式，考虑树的purfer编码，每次选取最小的一个叶子删去并将其邻接点加入purfer序列。
    
    具体令$dp_{V,S}$表示$V$集合组成的$S$不能为叶子的基环外向树数目。
    
    转移时我们令$k$为$V-S$中编号最小的节点，我们有两种转移方式：
    
    1.令$k$为叶子，并将$k$删去，那么我们在$k$的邻接点中选取一个节点$l$，将$l$设置为可以为叶子。
    
    2.将$k$设置为不可为叶子。
    
    当$V=S$时可以发现答案一定为一个环，即$dp_{V,S}=f_V$。
    
    注意到这样的统计会有重复计数，因为对于一个基环外向树，令其点集为$V'$，非叶节点集合为$S'$，那么对于所有$V=V',S \subseteq S'$都会被$dp_{V,S}$计数一次，
    共会被计数$2^{|S'|}$次，我们发现这恰好就是这个基环外向树的权值，那么对所有的$dp_{V,S}$求和即可。
    
    时间复杂度也是$O\left(3^n n\right)$，期望得分70分。

    \subsection{算法5}

    考虑对算法2进行优化，算法2的瓶颈在于计算集合$V$构成的环套树的方案数，而这个方案数在算法3中我们可以枚举叶子节点的集合进行容斥，而算法3的瓶颈在于莫比乌斯反演。

    我们考虑把算法2和算法3结合起来，我们直接枚举\textbf{非叶节点}集合$S$，在枚举$S$的超集$V$，枚举$V$可以使用dfs，在dfs的过程中计算$ways(V-S,S)$，使用如下容斥式子计算答案：

    $$g_V = \sum_{S \subset V} (-1)^{|V|-|S|} val_S ways(V-S,S)$$

    dfs之后统计$S$对于$V$的贡献即可，复杂度是$2^{n-|S|}$的，总复杂度就是$O\left(3^n\right)$了。

    \section{总结}


%% 解题报告结束

\end{document}
