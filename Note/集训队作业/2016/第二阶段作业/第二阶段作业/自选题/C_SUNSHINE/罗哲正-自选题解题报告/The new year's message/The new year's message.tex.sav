\documentclass{noiassignment}
\usepackage[CJKbookmarks,colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black]{hyperref}
\usepackage{CJKspace}

\begin{document}

%% 解题报告开始

\title{新年的贺电~解题报告}
\author{安徽师范大学附属中学~~罗哲正}

\maketitle

\section{试题来源}

UOJ Goodbye Yiwei E.新年的贺电

连接：\url{http://uoj.ac/contest/24/problem/178}。

\section{试题大意}

猴族一共拥有 $1024$ 台高达，每个高达有一个编号，为一个 $0$ 到 $2^{32} - 1$ 的整数。（不一定连续）

猴族一共拥有 $1024$ 个机库，编号为 $0$ 到 $1023$。每个高达都存放在某个机库中（\textbf{一个机库可能存放多个高达}）。

前线将领只知道自己管辖范围内的高达的编号而不知道位置，只有猴族首领猴腮雷清楚每个高达存放在哪个机库，所以他需要把位置信息发给前线将领。

但是，猴族的通讯技术不发达，猴族首领猴腮雷找到了你 ―― 请你设计一个通讯方式传输高达的位置。

\subsection{任务描述}
你需要写一个程序，实现编码和解码的功能。

\subsubsection{编码}
如果是编码，输入的第一行为一个字符串 \texttt{“encode”}。

接下来 $1024$ 行，每行两个整数 $k, v$，表示编号为 $k$ 的高达存放在编号为 $v$ 的机库。保证 $0 \leq k < 2^{32}$，$0 \leq v < 1024$，**保证 $k$ 互不相同**。

你需要输出一个\textbf{ 01 串 }，表示发送给前线将领的信息。

\subsubsection{解码}
如果是解码，输入的第一行为一个字符串 \texttt{“decode”}。

接下来一行，是你的程序编码出的 01 串。

接下来一行，一个正整数 $Q$，表示前线将领管辖了 $Q$ 个高达。

接下来 $Q$ 行，每行一个整数 $k$ 表示一个高达编号。保证一定是合法的高达编号，\textbf{保证编号互不相同}。

对于每个高达编号，你需要输出一行，为它所在的机库编号。

\subsection{限制与约定}
如果解码出的机库编号错误，直接 $0$ 分；

如果你的程序正常执行，设编码出的 01 串长度为 $n$，则你可以获得如下分数：

\begin{tabular}{|c|c|c|c|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  得分 & 条件 & 得分 & 条件 \\
  \hline
  1 & $n \leq 10^5$ & 6 & $m \leq 15000$ \\
  \hline
  2 & $n \leq 43008$ & 7 & $n \leq 14000$ \\
  \hline
  3 & $n \leq 40000$ & 8 & $n \leq 13000$ \\
  \hline
  4 & $n \leq 30000$ & 9 & $n \leq 12750$ \\
  \hline
  5 & $n \leq 20000$ & 10 & $n \leq 12500$ \\
  \hline
\end{tabular}

如果有多个条件被满足，取得分最高的那一个。

各测试点满足以下约定：

\begin{tabular}{|c|c|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  测试点编号 & 约定 \\
  \hline
  1 & \multirow{3}{*}{$0 \leq k \leq 1024$} \\
  \cline{1-1}
  2 &  \\
  \cline{1-1}
  3 &  \\
  \hline
  4 & \multirow{7}{*}{无} \\
  \cline{1-1}
  5 &  \\
  \cline{1-1}
  6 &  \\
  \cline{1-1}
  7 &  \\
  \cline{1-1}
  8 &  \\
  \cline{1-1}
  9 &  \\
  \cline{1-1}
  10 &  \\
  \hline
\end{tabular}

\section{算法介绍}

    \subsection{算法1}

    注意到$n \leq 43008$时没个测试点可以得到2分。
    
    观察$43008=(32+10) \times 1024$，而键有$32$位，值有$10$位，所以直接把健和值编码发过去就行了，恰好需要$43008$个bit，每个测试点可以得到两分。

    \subsection{算法2}

    注意到有$30\%$的数据$0 \leq k < 1024$，那么我们直接传一个长度为$1024$的数组$a_i$表示键为$i$时的值，长度是$10 \times 1024=10240$个bit，可以得到30分。

    配合上算法1，并使用传输字串长度来判断数据类型，可以得到$44$分。

    \subsection{算法3}

    $k<1024$的时候我们只需要$10240$个bit即可完成传输，那么我们考虑使用hash函数，把$[0,2^{32})$映射到$[0,M)$中，这样就可以使用算法2解决了。
    
    如何选取hash函数呢，我们考虑确定常数$a,b$使用$ak+b \mod M$取模后的值作为hash值。但是这样有一个问题，多个$k$可能对应着同一个hash值。
    对于这种情况，我们可以多随机几次，随机到不重复为止，然后把$a,b,m$都传过去就行了，编码长度是$64+10M$。
    
    然而你会发现这样做基本没有分，因为把n个数映射到$[0,M)$中不重复的概率是$\frac{\binom{M}{n}}{M^n}$，所以要想在时限内随机到一个合理的$a,b$，$M$不能取的很小。
    事实上$M$需要与$n^2$同级，而这是不可接受的。
    
    \subsection{算法4}
    
    算法3的尝试虽然失败了，但是取模给了我们一个好的思路，我们考虑在模意义下传输，想到使用多项式插值和求值来完成encode和decode的过程。
    
    选择一个模数$M$，然后构造多项式$f(x)$对于每一个$(k,v)$都有$f(k)=v$，这可以使用拉格朗日插值法来完成。
    这样传输的时候只需要传输$M$和模$M$意义下的$n-1$次多项式$f$即可，一共要传输$(n+1)\times L$个bit，其中$L$是$M$的二进制的长度。
    
    但是到算法3中的问题依然存在，可能有多个键值在模$M$意义下相等。
    我们考虑多随机几次选取$M$使得任意两个键值在模意义下不等，$M$取$2^20$级别的质数即可，这样传输长度就是$(1024+1)\times 20=20500$，每个测试点可以得到4分。
    
    事实上我们并不需要把$M$设那么大，$M$取$18$位就可以在时限内随机到可行的取值了，这样可以得到50分，结合算法1，可以得到65分。
    
    \subsection{算法6}
    
    使用插值算法已经几乎优化到极限了，我们重新开始考虑hash，有没有一种hash方式能够把$n$个$[0,2^{32})$级别的数映射到$[0,1024)$中呢？
    
    我们考虑建立

%% 解题报告结束

\end{document}
