\documentclass{noiassignment}

\begin{document}

%% 解题报告开始

\title{Bestcoder Round43 解题报告}
\author{浙江省余姚中学~~张浩威}

\maketitle

\section{摘要}

这是我在bestcoder上出的第三套题目，在这里分享一下出题的过程，试题可以在\uline{http://bestcoder.hdu.edu.cn/contests/contest\_show.php?cid=599}找到。

\section{1001}

\subsection{题目大意}

一开始有长度相等的字符串S1与S2，将S2翻转得到S3，令S=S1+S3。现在已知S，要求还原S1与S2。共有T组数据。

\subsection{数据范围}

$1\leq T \leq 100, 1\leq |S| \leq 100.$

\subsection{解析}

本题考查的是选手的字符串处理的能力。

我们只需将S的奇数位从前往后输出就能得到S1，偶数位从后往前输出就能得到S2。

对于刚入门的选手，字符串的读写可能是一个难题，本题在于巩固入门选手的基础。

\section{1002}

\subsection{题目大意}

在n个数中挑出两个数A与B，使得(A+B)对p取模后的余数最大。共有T组数据。

\subsection{数据范围}

$1\leq n \leq 10^5, 1\leq T \leq 5, 1\leq p,a_i \leq 2^{31}-1.$

\subsection{解析}

首先我们可以将所有$a_i$都对p取模，这对答案是没有任何影响的。

对于(A+B)有两种情况，一是大于等于p，二是小于p。

当$(A+B)\geq p$时，我们只需将A与B都取到最大值就可以了。

当$(A+B)<p$时，我们可以先将$a_i$从小到大排序，让A从前往后找，B从后往前找，要满足两者之和小于p，以此来更新最大值。

另外值得注意的是两个数相加是会超过longint的，需要用更高精度的类型或者用减法代替加法。

时间复杂度为排序的复杂度$O(nlog_2n)$。

\section{1003}

\subsection{题目大意}

给定一棵有n个节点的有根树，有Q个询问，每个询问求编号为$l_i$至$r_i$的点的最近公共祖先的编号。共有T组数据。

\subsection{数据范围}

$1 \leq T \leq 3, 1 \leq n,Q \leq 300000, 1 \leq li \leq ri \leq n.$

\subsection{解析}

对于3个点A,B,C的LCA，存在LCA(A,B,C)=LCA(LCA(A,B),C)。

因此我们就有了暴力的做法，对于每次询问，暴力枚举其中每一个编号，与当前最近公共祖先求LCA。 时间复杂度为$nQlog_2n$。难以通过本题。

注意到LCA具有交换律，因此我们可以用ST表来加速这个操作。

令lca[i][j]表示编号为$i$至$i+2^j-1$的点的LCA是多少。

那么对于每一个询问，它的答案就是LCA(lca[$l_i$][x],lca[$r_i-2^x+1$][x])，其中x表示l加上最大的二的幂次不超过r的数。

这样我们预处理出这个st表的时间为$nlog_2^2n$，仍然难以通过本题。

实际上求LCA是有线性做法的，因此时间复杂度可以降为$nlog_2n$。

当然也有另一种方法，我们先求出dfs序，令X为编号$l_i$至$r_i$中dfs序最小的点的编号，Y为dfs序最大的点的编号。那么答案就是LCA(X,Y)了。

这个证明比较繁琐，其实质与虚树是差不多的，读者可以去参考相关论文。

综上，时间复杂度为$nlog_2n$，可以通过本题。

本题主要考察选手的思维能力，当然如果选手有出色的代码能力，完全可以将LCA问题转换为RMQ问题来解决。这种一题多解的题目是很值得选手去进行研究分析的。

\section{1004}

\subsection{题目大意}

在一棵带点权有n个点的树上，对于一个点对(X,Y)（其中X不等于Y），它对答案的贡献为X走到Y的最短路上的点权的异或和。求对于所有这样的点对（共n*(n-1)对）对答案的贡献和是多少。

但是这个问题比较简单，现在有Q次操作，每次操作修改某个点权，求每次修改后所有点对对答案的贡献和是多少。共有T组数据。

\subsection{数据范围}

$1 \leq n,Q \leq 10000, 1 \leq T \leq 3, 0 \leq$ 点权 $\leq 32767.$

\subsection{解析}

对于一类异或问题，我们完全可以将它分解成二进制位，对于每一位单独处理。即题目可以转化为点权$\leq$1的问题。

没有修改时，我们可以进行点分治。这样我们只需处理经过根节点的路径的贡献，进行线扫，求出每个点到根节点的路径的异或和，最后进行统计就可以了。

这样时间复杂度为$O(n*log_2n*$位数$)$。

当有修改时，我们需要用线段树来维护每一层点分治树中的所有点到根节点的路径的异或和，一个点的点权只有可能从0变成1，或者从1变成0，其中受到影响的点在dfs序中一定是连续的一段。在这棵线段树中只需维护区间0的个数与1的个数，支持区间修改就可以了。

但是这个点分治套线段树的题比较难写，在比赛中是很难写出来的。

时间复杂度为$O(n*log_2^2n*$位数$)$

\section{得分情况}

共497人通过1001,97人通过1002,63人通过1003,0人通过1004。

\section{总结}

这套题既有思维题又有代码题，美中不足的是代码题在2小时的比赛中没有人能够写出来。

除了第二题略低于预估外，其余与预估得分相似。（第二题大部分人由于细节问题FST或被Hack）

\end{document}
