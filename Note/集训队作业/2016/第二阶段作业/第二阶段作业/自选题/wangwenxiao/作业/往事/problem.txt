往事(recollection)
时间限制：2 Sec 内存限制：256 MB
题目描述：
	往事太多，有时候忘了就忘了吧。
	如果有非记不可的，就只能用点附加手段啦！
	我们定义一棵往事树是一个n个点n-1条边的有向无环图，点编号为1到n，其中1号点被称为是根结点，除根结点以外，每个点都恰有一条出边（即以其作为起点的边）。每条边上有1个字符（这里我们实际上用一个不大于300的非负整数代表不同的字符），对于任意一个点u，u的所有入边（即以其为终点的边）上的字符互不相同。
	接下来我们定义往事，点u对应的往事为u到根的路径（显然有且只有一条）上的所有边按照从u到根经过的顺序排序后边上的字符依次拼接形成的字符串，简记为r(u)。
	一棵往事树的联系度取决于它包含的所有往事之中最相近的一对的相似度。具体的，我们定义2个点u和点v对应的往事的相似度f(u,v)如下。
	f(u,v)=Lcp(r(u),r(v))+Lcs(r(u),r(v))
	其中Lcp(a,b)表示字符串a和b的最长公共前缀的长度，Lcs(a,b)表示字符串a和b的最长公共后缀的长度。
	定义一棵往事树的联系度为所有满足1<=u<v<=n的f(u,v)的最大值。
	现在，给出一棵往事树，请你给出这棵往事树的联系度。
输入：
	第一行一个大于1的整数n表示给定的往事树的结点数。
接下来n-1行，每行2个整数。其中第i(1<=i<n)行的2个数依次表示点i+1的出边的终点和边上的字符。
输出：
	一行一个整数表示这棵往事树的联系度。
样例输入：
7
1 1
1 2
2 1
2 2
5 1
5 2

样例输出：
3

数据规模和约定：
	对于前10%的数据，n<=200。
	对于前30%的数据，n<=1500。
	另外有20%的数据，存在且仅存在一条边，使得其他所有边上的字符均相同。
	对于全部数据,n<=200000,出于简化目的，保证每条边的起点编号大于终点。
