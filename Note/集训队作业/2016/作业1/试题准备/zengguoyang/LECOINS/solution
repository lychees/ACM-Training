LECOINS
http://tsinsen.com/P7707
题目要求在n种硬币中各选择一些（可以不选），使硬币面值之和为S，在满足此条件基础上，希望硬币颜色种类尽量多。
可以先考虑一个简化的问题：是否存在一种选择方案使得硬币面值之和等于S？在解决这个简化版的问题后，我们再去思考如何解决原问题。
对于简化版问题，存在一种机智的做法：
	假设第i种硬币的面值为vi
	让 V = {v1, v2, v3 ... vn} 任取其中一个元素，记为M
	定义 dp[i] = x 为 “最小的x” 满足一下两个条件：
		1. x mod M = i
		2. x能够由 V - {M} 剩余的硬币组合而成
	
	显然 dp[0] = 0，其余为正无穷
	
	通过这个定义，我们还能得到一种简单的松弛操作
		dp[x] + vi -> dp[(x + vi) mod M]
	即
		建立一个有 M 个点的图，标号为0 ~ M - 1。
		对于每一个点 i，枚举接下来选择第j个硬币则建立有向边 i -> (i + vj) mod M 边权为 vj
		以0号点为原点，求出最短路。
		dp[i]的值就是原点到i的最短路长度
	
	通过上述方法能求出dp数组，接下来将说明如何使用dp数组判断：是否能够用这n种硬币构成价值S
	
	对于每一个价值S，考虑三种情况
		1. dp[S mod M] < S	表示 通过这n种硬币能够构成值S，并且一定使用了硬币M
		2. dp[S mod M] = S	表示 通过这n种硬币能够构成值S，并且一定没有使用硬币M
		3. dp[S mod M] > S	表示 通过这n种硬币不能够构成面值S
	
	这样我们就能利用dp数组判断：对于给定的S能不能使用这n种硬币构成。
	这个算法的瓶颈在于求最短路，所建图上有M个点n * M条边，如果使用Bellman-Ford复杂度为O(M ^ 2 * N)，如果使用dijkstra复杂度请自行计算。
	
	这个算法还有待优化。经过观察，我们会发现这样一个事实：对于每一种硬币的使用，我们可以分开考虑。
	例如我们选择硬币 v1 + v2 + v1 等价于我们选择硬币 v1 + v1 + v2。
	所以我们可以定义状态 dp[j][i] = x 表示考虑前j种硬币，且满足之前条件的最小的x。
	转移为
		dp[j][(i + k * vj) mod M] = min{dp[j - 1][i] + k * vj}
	然而，这样的复杂度还是 O(M ^ 2 * N) 的，不过可以很方便的进行优化。
	仔细观察以下转移：
		i -> (i + v) mod M
		(i + v) mod M -> (i + 2v) mod M
		...
		(i + kv) mod M -> i
	很容易发现我们的转移会形成一些环，而经过推导可以发现这些转移会形成gcd(v, M)个环。
	我们对于每一个环单独考虑：
		对于环上点u我们找到u`使得dp[j - 1][u`]最小，显然转移 u` -> (u` + vj) mod M 已经使得 dp[j][(u` + j) mod M]的值达到最优
		因此我们去掉除u`外所有到(u` + vj) mod M的转移，将环上的问题转化为线段上的问题，即可在O(len)的时间内解决（len为环的大小）
		所有环转移的总代价因此为O(M)
	于是这个算法就被优化成了O(N * M)

至此简化版的问题就解决了，我们已经能求出对于S是否存在解了。
对于最优化解，可以这样思考：
	在原状态dp[j][i]的基础上加上一维变为dp[j][i][color]表示已经考虑前j种硬币有color种颜色，满足之前条件的最小的x
	我们把颜色相同的硬币放在一块儿，在之前的转移上我们稍微做一些改变：
		如果第j - 1个硬币的颜色和第j个硬币颜色不同
			dp[j][(i + k * vj) mod M][color + 1] = min{dp[j - 1][i][color] + k * vj}
		否则
			dp[j][(i + k * vj) mod M][color] = min{dp[j - 1][i][color] + k * vj}
	这两个转移的区别仅在于是否让已经选择的颜色种数+1
	这样整个算法的复杂度就变成了 O(C * N * M) C为颜色的种类数
	这样对于每一个S我们枚举选择颜色的总数c
	这样分三种情况讨论
		1. dp[n][S mod M][c] < S 表示能够构成值S且使用了c + 1种颜色，且一定使用了硬币M（注意在dp中我们没有考虑是否使用硬币M，也就是说我们的颜色种数C没有考虑硬币M，所以我们需要将颜色种数+1）
		2. dp[n][S mod M][c] = S 表示能够构成值S且使用了c 种颜色，且一定没有使用硬币M
		3. dp[n][S mod M][c] > S 表示不能够构成值S
	处理这些情况对答案的贡献，即为我们的最终答案。
这个算法的复杂度是O(C * N * M + Q * C) 其中C为颜色种数

对于空间大小，可以使用滚动的方法优化，注意颜色可能会重复，对于这些情况要特殊处理。
