这一题……其实2bx最后想了好久终于?想出来了。
（好像混进了什么奇怪的东西）
（不要在意这些细节）

这一题，一开始可以想到，
所用字符种类数已经确定了，
然后可以想到：

对于一个长度为N的字符串st总会存在一个L，	（其中0<=L<N）
使得长度不大于L的后缀都是其他后缀的前缀，
而长度大于L的后缀都不是。
我们称长度不大于L的后缀为短后缀，
长度大于L的后缀为长后缀，
其中长度恰为L+1的后缀称为中长后缀M。

这时候整理一下接下来叙述中会用到的定义：	（由于2bx语文能力实在是渣，要用这么多定义实在不好意思）
str(a) 节点a对应的字符串，其中根节点对应空串
node(A) 后缀A对应的节点，显然str(node(A))==A
{A} 后缀A的长度
lca(A,B) 后缀A和B的最长公共前缀
fa[a] 节点a的父节点
char[a] str(a)的最后一位
	（即和str(fa[a])相比多出来的一位）
next(A) 若对于后缀A和B有[B]+1==[A]，那么B=next(A)

也就是说，放到这道题里面，
意思就是node(长后缀)都是叶子节点。
而node(短后缀)都不是。

那么，也就是说，
node(长后缀)都是叶子节点，
并且node(长后缀)的位置已经知晓，
这些长后缀的第一个字符，
它们之间的相等关系已经确定了。
（若lca为根，第一个字符不同，否则相同）

因此，为了下面叙述方便，
虽然st[0..L-1]可能会换成不同字符，
但是我们可以假设st[0..N-L-1]已经固定了，	<========假设①
而能变的最多只有后面的st[N-L..N-1]。

然后对于每一个长后缀，
定义其后L位的节点为尾节点，尾节点对应字符st[N-L..N-1]。
前面的节点为头节点，头节点对应字符st[0..N-L-1]。

显然对于一个长后缀A的头节点a，
和另一个长后缀B的尾节点b，		（显然此时{B}<{A}）
如果fa[a]==fa[b]那么：
char[a]==char[b]当且仅当a==b。		<========关系②
也就是说，利用这些可以找到后L个字符。

那么这些关系（以下称“关系②”）有什么共同点呢？
{lca(A,B)}>={B}-L一定成立。

再然后我们就会发现：
如果A的头节点a和B的尾节点b存在关系②的话，
那么由{lca(next[A],next[B])}={lca(A,B)}-1，
我们可以认为，next[A]和next[B]中对应位置的节点
就一定存在关系②。

也就是说，像这样一步步减少{A}和{B}，
到最后，所有长后缀之间的关系②一定会转化为
中长后缀M和其他后缀A之间的关系②。
这就是前面特别讲到的中长后缀M的特别之处。

这时候基本的方向已经呼之欲出。
首先找出后缀M和其他长后缀A的{lca(M,A)}-1的最大值H。	（显然H<L，否则L可以更大）
这样一来，st[N-L..N-L+H-1]便容易确定。
然后M对应st[N-L+H]的节点一定还会有关系②。

那么怎么找出这些关系②呢？
首先找到所有的长后缀C使得{lca(M,C)}==H+1
然后从这些长后缀里面求出st[N-L+H]不可能是哪些字符。

在找到和st[N-L+H]不相等的所有字符以后，
我们就可以确信，st[N-L+H+1..N-1]这些字符已经不受限制了。

最终，问题转化为，对于{A}==L的后缀A，
找出node(A)的所有可能位置。
要求这个可能位置，只需要以下条件：
一，已经固定下来的st[N-L..N-L+H-1]
二，和st[N-L+H]不相等的所有字符
三，树的形态

然后用后缀数组（满足条件三）
找出满足条件一的后缀所在的排名范围，
再一个个比较排除掉条件二中不相等的字符。
统计满足条件的位置个数。

然后再乘以假设①中字符组成变化的方案数就能得到答案了。