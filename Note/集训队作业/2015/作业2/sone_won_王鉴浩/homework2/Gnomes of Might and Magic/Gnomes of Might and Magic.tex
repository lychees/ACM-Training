\documentclass{noiassignment}
\usepackage[all]{xy}
\setlength{\parskip}{0.5\baselineskip}
\usepackage[colorlinks, citecolor = green, linkcolor = blue, menucolor = red, CJKbookmarks=true]{hyperref}

\begin{document}

%% 解题报告开始

\title{Gnomes of Might and Magic 解题报告}
\author{绍兴市第一中学~~王鉴浩}

\maketitle

\section{试题来源}

\href{http://codeforces.com/contest/175/problem/F}{CF~175F}

\section{试题大意}

有一个~$m$~个点的环，在环上相邻两个点中除了环上原来的边还有一条路径，这条路径中的边数大于~1。
一共有~$n$~个点。

现在有~$q$~个操作，操作有两种：
\begin{itemize}
  \item 把一条边的边权加~1。
  \item 选择两个点~$x,y$，找一条从~$x$~到~$y$~的最优路径。输出这条路径的边权和，然后把这条路径上的所有边权赋值为~0。
        最优路径为：首先保证路径边权和最小，如果有多条最小的，要求路径边的条数最小，如果又有多条一样的，那么要求这条路径的字典序最小。
        路径的字典序是：把这条路径上的点的编号按遍历顺序排成一个数列，把这个数列当字符串进行字典序比较。
\end{itemize}

数据范围：$1\le m\le n\le 100000,1\le q\le 100000$

时限：$8s$

\section{算法介绍}

我们可以发现对于这~$m$~个点的环，每相邻两个点之间也有一个环。
首先我们可以把~$m$~个点的大环从一处断开，成为链：
$$\xymatrix@C=50pt{
            1 \ar@/^1.3pc/@{--}[r] \ar@/_1.3pc/@{-}[r] & 2 \ar@/^1.3pc/@{--}[r] \ar@/_1.3pc/@{-}[r]\ar@/_1.3pc/@{-}[r] & 3 \ar@/^1.3pc/@{--}[r] \ar@/_1.3pc/@{-}[r] & .~.~. \ar@/^1.3pc/@{--}[r] \ar@/_1.3pc/@{-}[r] & m \ar@/^1.3pc/@{--}[r] \ar@/_1.3pc/@{-}[r] & 1
          }
          $$

对于上图中虚线路径中的每条边，我们使用线段树来维护，支持快速计算任意两个点直接的边权和。
我们还需要在大环上计算任意两个点直接的路径。
由于大环已经被我们断成了链，所以现在我们需要计算在这条链上任意两个点直接的路径。
对于大环相邻两个点直接的路径，有两种情况，我们选择最优的作为这两个点直接的路径。
然后对于这些路径，我们再用线段树来维护这些路径，于是我们就可以快速地对链上两个点路径进行计算了。

现在，我们需要进行最优路径的计算。每次询问选择的两个点~$x$~和~$y$，这两个点之间的路径的选择会有如下情况：
\begin{enumerate}
  \item 从~$x$~出发，到这个小环的端点有两种情况。
  \item 以~$y$~为终点，从这个小环的两个端点到~$y$~有两种情况。
  \item 对于大环的两个点，它们之间路径有两种走法。
\end{enumerate}

对这~3~种情况进行排列枚举会形成~8~种情况。

现在，我们需要对这~8~种情况进行枚举，选择其中最优的路径作为答案。
如果我们忽略字典序的话，只需要在线段树维护的同时计算边权和和边数就可以了。

于是，边权和和边数都是最优的，我们只需考虑字典序。
对于路径，我们可以对于路径的选择把其分成~3~段，对于每一段，我们分开考虑：
\begin{enumerate}
  \item 对于第一段，我们可以发现如果第一段不相同的话，字典序可以直接判断了。但由于起始点是一样的，所以我们需要在线段树维护的时候记录以遍历到的前两个点作为关键字。
  \item 对于第二段，我们也可以和第一段一样判断。
  \item 如果前两端都无法判断出的话，我们考虑第三段。由于边数和是一定的，且前两端的方向已经固定了，所以对于这两个第三段一定有一个比另一个边数多~1~条。 于是，我们就可以直接比较了。
\end{enumerate}

那么此题就解决了，上述解法的时间复杂度是~$O(n+2^3q\log n)$。

%% 解题报告结束

\end{document}
